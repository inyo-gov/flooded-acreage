[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Flood Report Dashboard",
    "section": "",
    "text": "Flood Report Links\n\nbwma_flood_report_2024-10-22_0.22.html\nbwma_flood_report_2024-11-03_0.22.html\n\nSelected Report Preview Below is a preview of a default flood report. Click on any report link above to view it directly in a new tab."
  },
  {
    "objectID": "flood_app.html",
    "href": "flood_app.html",
    "title": "Parameters",
    "section": "",
    "text": "Import necessary libraries authenticate using gcloud api enabled on gcloud project\n\n# 1 import libraries\nimport ee\nimport geopandas as gpd\nimport geemap\nimport pandas as pd\nimport folium\nimport geemap.foliumap as geemap\nfrom datetime import datetime, timedelta\nimport os\n\nTrigger authentication\n\n\n# run this in terminal to authenticate with gcloud &gt;&gt; earthengine authenticate\n\n\n            \n            \n\n\nInitialize Earth Engine\n\n\n\nee.Initialize()\n\n\n            \n            \n\n\nsurface reflectance threshold start date the end date is currently start date + 15 days and the first clear scene, low cloud cover will be selected and the image date is used in the reporting and filenaming convention along with the SR threshold value.\nSpring 2023\n\n#---Mar 2023---730 ac***\n# threshold = .15\n# start_date = '2023-02-15'\n\n#---Mar 2023---1604 ac\n# threshold = .20\n# start_date = '2023-02-15'\n\n#---May 2023---300 ac\n# threshold = .15\n# start_date = '2023-05-01'\n\n#---May 2023---449 ac\n# threshold = .20\n# start_date = '2023-05-01'\n\n\n            \n            \n\n\nFall 2023\n\n\n#---Oct 2023---1175 ac\n# threshold = .22\n# start_date = '2023-10-03'\n\n#---Nov 2023---618 ac\n# threshold = .16\n# start_date = '2023-11-03'\n\n#---Nov 2023---760 ac\n# threshold = .18\n# start_date = '2023-11-03'\n\n#---Nov 2023---987 ac\n# threshold = .20\n# start_date = '2023-11-03'\n\n#---Nov 2023--- 1125 ac\n# threshold = .21\n# start_date = '2023-11-03'\n\n#---Nov 2023---1325 ac***\n# threshold = .22\n# start_date = '2023-11-03'\n\n\n\n\n            \n            \n\n\nSpring 2024\n\n\n#---Mar 2024---1130 acres***\n# threshold = .15\n# start_date = '2024-02-25'\n\n#---Mar 2024---1355 acres***\n# threshold = .16\n# start_date = '2024-02-25'\n\n#---May 2024---\n# start_date = '2024-05-10'\n# threshold = .22\n\n#---Jun 2024---92 ac\n# start_date = '2024-06-01'\n# threshold = .15\n\n#---Jun 2024---109 ac\n# start_date = '2024-06-01'\n# threshold = .16\n\n#---Jun 2024---109 ac\n# start_date = '2024-06-06'\n# threshold = .16\n\n\n            \n            \n\n\nFall 2024\n\n\n\nthreshold = .21\nstart_date = '2024-09-22'\n\n\n            \n            \n\n\nCompute the end date by adding days to the start date\n\n\n\nend_date = (datetime.strptime(start_date, '%Y-%m-%d') + timedelta(days=15)).strftime('%Y-%m-%d')\n\n\n            \n            \n\n\nReport Directory\n\n\n\nDefine the bounding box coordinates and create a bounding box geometry\n\n# Define the bounding box coordinates\n\nbbox = [[-118.23240736400778, 36.84651455123723],\n        [-118.17232588207419, 36.84651455123723],\n        [-118.17232588207419, 36.924364295139625],\n        [-118.23240736400778, 36.924364295139625]]\n\n# Create a bounding box geometry\nbounding_box_geometry = ee.Geometry.Polygon(bbox)\n\n\n            \n            \n\n\nFilter sentinel 2 surface reflectance imagery and extract dates, pixel size\n\n# COPERNICUS/S2_SR_HARMONIZED, allows comparisons between dates compared to S2_SR\nsentinel_collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterBounds(bounding_box_geometry) \\\n    .filterDate(start_date, end_date) \\\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)) \\\n    .select(['B8', 'SCL','B3','B4','B11'])  # Select NIR band (B8) and Scene Classification Layer (SCL) for masking clouds\n\n\n            \n            \n\n\n\n\nsize = sentinel_collection.size().getInfo()\nprint(f\"Number of images in collection: {size}\")\n\n\n\n            \n            \n\n\nNumber of images in collection: 1\n\n\n\n\n# Select a single band before retrieving the projection information\npixel_size = sentinel_collection.first().select('B8').projection().nominalScale().getInfo()\n\n\n            \n            \n\n\n\n\n# Extract the date information\nimage_info = sentinel_collection.first().getInfo()\nimage_date = image_info['properties']['system:time_start']\nimage_date_str = pd.to_datetime(image_date, unit='ms').strftime('%Y-%m-%d')\n\n\n\n            \n            \n\n\nreport and map directories and file names\n\n# directory location for reports\nhtml_subdirectory = \"flood_reports/html_reports_maps\"\nos.makedirs(html_subdirectory, exist_ok=True)\n\n\n# Define filenames with unique names based on the image date\nreport_filename = os.path.join(html_subdirectory, f\"bwma_flood_report_{image_date_str}_{threshold}.html\")\nmap_filename = os.path.join(html_subdirectory, f\"flooded_area_map_{image_date_str}_{threshold}.html\")\n\n\n            \n            \n\n\nCreate a cloud-free composite by masking cloudy pixels\n\n\n\n\ndef mask_clouds(image):\n    cloud_prob = image.select('SCL')  # Scene Classification Layer (SCL)\n    is_cloud = cloud_prob.eq(9)  # 9 represents clouds in the SCL\n    return image.updateMask(is_cloud.Not())\n\ncloud_free_composite = sentinel_collection.map(mask_clouds).median()\n\n\n            \n            \n\n\nDefine binary image base on the threshold\n\nbinary_image = cloud_free_composite.select('B8').divide(10000).lt(threshold).selfMask()\n\n\n            \n            \n\n\nLoad units from geojson and convert to earth engine geometry\n\ngdf = gpd.read_file(\"data/unitsBwma2800.geojson\")\nunits = geemap.geopandas_to_ee(gdf)\nunits = units.filterBounds(bounding_box_geometry)\nunits_clipped = units.map(lambda feature: feature.intersection(bounding_box_geometry))\n\n\n            \n            \n\n\nCompute the unit area and flooded area\n\n# Compute area of each unit\ndef compute_area(feature):\n    return feature.set({'unit_acres': feature.geometry().area().divide(4046.86)})\n\nunits_with_area = units_clipped.map(compute_area)\n\n# Compute the flooded area within each unit\ndef compute_refined_flood_area(feature):\n    geom = feature.geometry()\n    total_pixels = cloud_free_composite.select('B8').reduceRegion(\n        reducer=ee.Reducer.count(), geometry=geom, scale=10).get('B8')\n    flooded_pixels = binary_image.reduceRegion(\n        reducer=ee.Reducer.count(), geometry=geom, scale=10).get('B8')\n    pixel_area_m2 = ee.Number(pixel_size).multiply(pixel_size)\n    pixel_area_acres = pixel_area_m2.multiply(0.000247105)\n    flooded_area_acres = ee.Number(flooded_pixels).multiply(pixel_area_acres)\n    flooded_percentage = ee.Number(flooded_pixels).divide(total_pixels).multiply(100)\n    unit_name = feature.get('Flood_Unit')\n    label = ee.String(unit_name).cat(': ').cat(flooded_area_acres.format('%.2f')).cat(' Acres')\n    return feature.set({\n        'total_pixels': total_pixels,\n        'flooded_pixels': flooded_pixels,\n        'acres_flooded': flooded_area_acres,\n        'flooded_percentage': flooded_percentage,\n        'label': label\n    })\n\nunits_with_calculations = units_with_area.map(compute_refined_flood_area)\n\n\n            \n            \n\n\nConvert EE feature collection to Pandas DataFrame\n\n\nunits_df_properties_reduced = pd.DataFrame(units_with_calculations.getInfo()['features'])\nunits_df_properties_reduced = pd.json_normalize(units_df_properties_reduced['properties'])\nunits_df_properties_reduced = units_df_properties_reduced[['Flood_Unit', 'total_pixels', 'flooded_pixels', 'unit_acres', 'acres_flooded', 'flooded_percentage']]\n\n# Round numbers\nunits_df_properties_reduced = units_df_properties_reduced.round(2)\n\n\n            \n            \n\n\nCalculate Total Acreage and add total row\n\n# Calculate totals\ntotal_acres = units_df_properties_reduced['unit_acres'].sum()\ntotal_flooded_acres = units_df_properties_reduced['acres_flooded'].sum()\ntotal_flooded_percentage = (total_flooded_acres / total_acres) * 100\n\n# Add a row for totals\ntotals = pd.DataFrame([{\n    'Flood_Unit': 'Total',\n    'total_pixels': units_df_properties_reduced['total_pixels'].sum(),\n    'flooded_pixels': units_df_properties_reduced['flooded_pixels'].sum(),\n    'unit_acres': total_acres,\n    'acres_flooded': total_flooded_acres,\n    'flooded_percentage': total_flooded_percentage\n}])\n\n# Concatenate totals to the original dataframe\nunits_df_properties_reduced = pd.concat([units_df_properties_reduced, totals], ignore_index=True)\n\n# Round the totals row\nunits_df_properties_reduced = units_df_properties_reduced.round(2)\n\n# Display the formatted DataFrame\nprint(units_df_properties_reduced.to_string(index=False))\n\n\n\n            \n            \n\n\n     Flood_Unit  total_pixels  flooded_pixels  unit_acres  acres_flooded  flooded_percentage\n        Thibaut         99955            2592     1971.07          64.05                2.59\n           Drew         25462             806      502.65          19.92                3.17\n      Waggonner         63198            1214     1246.13          30.00                1.92\n West Winterton         40855            1633      805.68          40.35                4.00\n East Winterton         17010               9      335.14           0.22                0.05\nSouth Winterton         26035              31      513.46           0.77                0.12\n  Thibaut Ponds         26753             504      527.63          12.45                1.88\n          Total        299268            6789     5901.76         167.76                2.84\n\n\nCreate and Save HTML Map\n\n# Define visualization parameters for a better false-color composite\nfalse_color_vis = {\n    'min': 0,\n    'max': 3000,\n    'bands': ['B11', 'B8', 'B4'],  # SWIR1 (B11), NIR (B8), Red (B4)\n    'gamma': 1.4\n}\n\n# Create the Sentinel-2 image collection filtered by date, cloud cover, and bounds\nsentinel_collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterBounds(bounding_box_geometry) \\\n    .filterDate(start_date, end_date) \\\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)) \\\n    .select(['B8', 'B11', 'B4', 'SCL'])  # Select NIR (B8), SWIR1 (B11), Red (B4), and Scene Classification Layer (SCL)\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the false-color composite to the map\nMap.addLayer(sentinel_collection.median(), false_color_vis, 'False-Color Composite')\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map with Layer Control\nMap.add_child(folium.LayerControl())\n\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\n\n\n\n\n\nfalse_color_vis = {\n    'min': 0,\n    'max': 3000,\n    'bands': ['B11', 'B8', 'B4'],  # SWIR1 (B11), NIR (B8), Red (B4)\n    'gamma': 1.4\n}\n\n# Create the Sentinel-2 image collection filtered by date, cloud cover, and bounds\nsentinel_collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterBounds(bounding_box_geometry) \\\n    .filterDate(start_date, end_date) \\\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)) \\\n    .select(['B8', 'B11', 'B4', 'SCL'])  # Select NIR (B8), SWIR1 (B11), Red (B4), and Scene Classification Layer (SCL)\n\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the false-color image to the map (assuming 'image' is your Sentinel-2 or equivalent image)\nMap.addLayer(image, false_color_vis, 'False-Color Composite')\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map with Layer Control\nMap.add_child(folium.LayerControl())\n\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\nNameError: name 'image' is not defined\n\n\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map\nMap.add_child(folium.LayerControl())\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\n\n\n\n\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map\nMap.add_child(folium.LayerControl())\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\n\n\n\n\nWrite csv Table\n\n\n# Define the subdirectory for CSV output\ncsv_subdirectory = \"flood_reports/csv_output\"\nos.makedirs(csv_subdirectory, exist_ok=True)\n\n# Save the DataFrame to a CSV file\nunits_df_properties_reduced = pd.DataFrame(units_with_calculations.getInfo()['features'])\nunits_df_properties_reduced = pd.json_normalize(units_df_properties_reduced['properties'])\nunits_df_properties_reduced = units_df_properties_reduced[['Flood_Unit', 'total_pixels', 'flooded_pixels', 'unit_acres', 'acres_flooded']]\n\n# Define the CSV filename with the new directory\ncsv_filename = os.path.join(csv_subdirectory, f'flood_report_data_{image_date_str}_{threshold}.csv')\n\n# csv_filename = f'flood_report_data_{image_date_str}.csv'\nunits_df_properties_reduced.to_csv(csv_filename, index=False)\n\n\n            \n            \n\n\nCreate HTML Table\n\n\n# Rename columns for display\nunits_df_properties_reduced = units_df_properties_reduced[['Flood_Unit', 'acres_flooded']]\nunits_df_properties_reduced.columns = ['BWMA Unit', 'Acres']\n\n# Round acres to whole numbers\nunits_df_properties_reduced['Acres'] = units_df_properties_reduced['Acres'].round(0).astype(int)\n\n# Calculate totals\ntotal_acres = units_df_properties_reduced['Acres'].sum()\ntotals_row = pd.DataFrame([{'BWMA Unit': 'Total', 'Acres': total_acres}])\n\n# Append the totals row to the DataFrame\nunits_df_properties_reduced = pd.concat([units_df_properties_reduced, totals_row], ignore_index=True)\n\n\n# Style the DataFrame and convert to HTML\nhtml_table_simple = (\n    units_df_properties_reduced.style\n    .set_table_styles([\n        {'selector': 'th', 'props': [('text-align', 'center'), ('font-size', '14px')]},\n        {'selector': 'td:nth-child(1)', 'props': [('text-align', 'left'), ('font-size', '12px')]},\n        {'selector': 'td:nth-child(2)', 'props': [('text-align', 'right'), ('font-size', '12px')]},\n    ])\n    .set_properties(subset=pd.IndexSlice[units_df_properties_reduced.index[-1], :], **{'font-weight': 'bold', 'font-size': '14px'})\n    .hide(axis='index')\n    .to_html()\n)\n\n\n# Manually hide the index in the HTML string\nhtml_table_simple = html_table_simple.replace('&lt;th&gt;&lt;/th&gt;', '')\n\n\n            \n            \n\n\nCreate HTML Report\n\n\n\n# HTML report\nhtml_report = f\"\"\"\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;BWMA Flooded Extent: {image_date_str}&lt;/title&gt;\n    &lt;style&gt;\n        body {{\n            font-family: Arial, sans-serif;\n        }}\n        .container {{\n            display: flex;\n            justify-content: space-between;\n        }}\n        .left {{\n            width: 25%;\n        }}\n        .right {{\n            width: 75%;\n            text-align: center;\n        }}\n        h1, h2 {{\n            text-align: center;\n        }}\n        .notes {{\n            margin-top: 20px;\n            padding: 10px;\n            border-top: 1px solid #000;\n        }}\n        /*----CHANGE---- Increase font size and add line above totals row */\n        table {{\n            width: 90%;\n            font-size: 50px;\n            border-collapse: collapse;\n        }}\n        th, td {{\n            padding: 20px;\n            text-align: left;\n            border-bottom: 1px solid #ddd;\n        }}\n        th {{\n            text-align: right;//from center\n            font-size: 30px;\n        }}\n        td:nth-child(2) {{\n            text-align: right;\n        }}\n        tr:last-child {{\n            font-weight: bold;\n            font-size: 80px;\n        }}\n        tr:last-child td {{\n            border-top: 3px solid #000;\n        }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;BWMA Flooded Acres and Extent: {image_date_str}&lt;/h1&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"left\"&gt;\n            &lt;h2&gt;Flooded Acres&lt;/h2&gt;\n            {html_table_simple}\n        &lt;/div&gt;\n        &lt;div class=\"right\"&gt;\n            &lt;h2&gt;Spatial Extent&lt;/h2&gt;\n            &lt;p&gt;Imagery Date: {image_date_str}&lt;/p&gt;\n            &lt;iframe src=\"flooded_area_map_{image_date_str}_{threshold}.html\" width=\"90%\" height=\"500\"&gt;&lt;/iframe&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"notes\"&gt;\n        &lt;h3&gt;Technical Notes&lt;/h3&gt;\n        &lt;p&gt;Flooded acres were calculated from Sentinel-2 Surface Reflectance imagery using the Earth Engine Python API in a Jupyter notebook.  Sentinel-2 (S2) is a wide-swath, high-resolution, multispectral imaging mission with a global 5-day revisit frequency.&lt;/p&gt;\n        &lt;p&gt;The S2 Multispectral Instrument (MSI) samples 13 spectral bands: Visible and NIR at 10 meters, red edge and SWIR at 20 meters, and atmospheric bands at 60 meters spatial resolution. The Near Infrared (NIR) band was used to identify flooded areas by applying a threshold to isolate water.&lt;/p&gt;\n        &lt;p&gt;The results are validated during routine field checks throughout the seasonal flooding cycle September through April.&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n# Save the report to an HTML file in the subdirectory\nwith open(report_filename, \"w\") as file:\n    file.write(html_report)\n\nprint(f\"Report saved to {report_filename}\")\nprint(f\"Map saved to {map_filename}\")\n\n\n            \n            \n\n\nReport saved to flood_reports/html_reports_maps\\bwma_flood_report_2024-09-22_0.21.html\nMap saved to flood_reports/html_reports_maps\\flooded_area_map_2024-09-22_0.21.html"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Technical Notes\n\nFlooded acres were calculated from Sentinel-2 Surface Reflectance imagery using the Earth Engine Python API. Sentinel-2 (S2) is a wide-swath, high-resolution, multispectral imaging mission with a global 5-day revisit frequency. The S2 Multispectral Instrument (MSI) samples 13 spectral bands: Visible and NIR at 10 meters, red edge and SWIR at 20 meters, and atmospheric bands at 60 meters spatial resolution.\nThe Near Infrared (NIR) band with 10m pixel resolution was used to identify flooded areas by applying a reflectance threshold to isolate water from surrounding vegetation. The flooded extent predictions are verified in the field during avian surveys throughout the seasonal flooding cycle September through April.\njupyter notebook"
  }
]