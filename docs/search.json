[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blackrock Waterfowl Management Area",
    "section": "",
    "text": "fy_label\nJul\nAug\nSep\nOct\nNov\nDec\nJan\nFeb\nMar\nApr\nMay\nJun\n\n\n\n\n2024-25\n\n\n22\n22\n03\n06\n05\n21\n01\n04\n02\n04"
  },
  {
    "objectID": "flood_app.html",
    "href": "flood_app.html",
    "title": "Parameters",
    "section": "",
    "text": "Import necessary libraries authenticate using gcloud api enabled on gcloud project\n\n# 1 import libraries\nimport ee\nimport geopandas as gpd\nimport geemap\nimport pandas as pd\nimport folium\nimport geemap.foliumap as geemap\nfrom datetime import datetime, timedelta\nimport os\n\nTrigger authentication\n\n\n# run this in terminal to authenticate with gcloud &gt;&gt; earthengine authenticate\n\n\n            \n            \n\n\nInitialize Earth Engine\n\n\n\nee.Initialize()\n\n\n            \n            \n\n\nsurface reflectance threshold start date the end date is currently start date + 15 days and the first clear scene, low cloud cover will be selected and the image date is used in the reporting and filenaming convention along with the SR threshold value.\nSpring 2023\n\n#---Mar 2023---730 ac***\n# threshold = .15\n# start_date = '2023-02-15'\n\n#---Mar 2023---1604 ac\n# threshold = .20\n# start_date = '2023-02-15'\n\n#---May 2023---300 ac\n# threshold = .15\n# start_date = '2023-05-01'\n\n#---May 2023---449 ac\n# threshold = .20\n# start_date = '2023-05-01'\n\n\n            \n            \n\n\nFall 2023\n\n\n#---Oct 2023---1175 ac\n# threshold = .22\n# start_date = '2023-10-03'\n\n#---Nov 2023---618 ac\n# threshold = .16\n# start_date = '2023-11-03'\n\n#---Nov 2023---760 ac\n# threshold = .18\n# start_date = '2023-11-03'\n\n#---Nov 2023---987 ac\n# threshold = .20\n# start_date = '2023-11-03'\n\n#---Nov 2023--- 1125 ac\n# threshold = .21\n# start_date = '2023-11-03'\n\n#---Nov 2023---1325 ac***\n# threshold = .22\n# start_date = '2023-11-03'\n\n\n\n\n            \n            \n\n\nSpring 2024\n\n\n#---Mar 2024---1130 acres***\n# threshold = .15\n# start_date = '2024-02-25'\n\n#---Mar 2024---1355 acres***\n# threshold = .16\n# start_date = '2024-02-25'\n\n#---May 2024---\n# start_date = '2024-05-10'\n# threshold = .22\n\n#---Jun 2024---92 ac\n# start_date = '2024-06-01'\n# threshold = .15\n\n#---Jun 2024---109 ac\n# start_date = '2024-06-01'\n# threshold = .16\n\n#---Jun 2024---109 ac\n# start_date = '2024-06-06'\n# threshold = .16\n\n\n            \n            \n\n\nFall 2024\n\n\n\nthreshold = .22\nstart_date = '2024-11-04'\n\n\n            \n            \n\n\nCompute the end date by adding days to the start date\n\n\n\nend_date = (datetime.strptime(start_date, '%Y-%m-%d') + timedelta(days=15)).strftime('%Y-%m-%d')\n\n\n            \n            \n\n\nReport Directory\n\n\n\nDefine the bounding box coordinates and create a bounding box geometry\n\n# Define the bounding box coordinates\n\nbbox = [[-118.23240736400778, 36.84651455123723],\n        [-118.17232588207419, 36.84651455123723],\n        [-118.17232588207419, 36.924364295139625],\n        [-118.23240736400778, 36.924364295139625]]\n\n# Create a bounding box geometry\nbounding_box_geometry = ee.Geometry.Polygon(bbox)\n\n\n            \n            \n\n\nFilter sentinel 2 surface reflectance imagery and extract dates, pixel size\n\n# COPERNICUS/S2_SR_HARMONIZED, allows comparisons between dates compared to S2_SR\nsentinel_collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterBounds(bounding_box_geometry) \\\n    .filterDate(start_date, end_date) \\\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)) \\\n    .select(['B8', 'SCL','B3','B4','B11'])  # Select NIR band (B8) and Scene Classification Layer (SCL) for masking clouds\n\n\n            \n            \n\n\n\n\nsize = sentinel_collection.size().getInfo()\nprint(f\"Number of images in collection: {size}\")\n\n\n\n            \n            \n\n\nNumber of images in collection: 1\n\n\n\n\n# Select a single band before retrieving the projection information\npixel_size = sentinel_collection.first().select('B8').projection().nominalScale().getInfo()\n\n\n            \n            \n\n\n\n\n# Extract the date information\nimage_info = sentinel_collection.first().getInfo()\nimage_date = image_info['properties']['system:time_start']\nimage_date_str = pd.to_datetime(image_date, unit='ms').strftime('%Y-%m-%d')\nimage_date_str = \"2024-11-06\"\n\n\n            \n            \n\n\n\nfrom PIL import Image\nimage_date_str = \"2024-11-06\"\nthreshold = \"0.22\"\nfalse_color_filename_png = f\"docs/reports/false_color_composite_{image_date_str}_{threshold}.png\"\nflooded_pixels_filename_png = f\"docs/reports/flooded_pixels_{image_date_str}_{threshold}.png\"\nfalse_color_filename_tif = f\"docs/reports/false_color_composite_{image_date_str}_{threshold}.tif\"\nflooded_pixels_filename_tif = f\"docs/reports/flooded_pixels_{image_date_str}_{threshold}.tif\"\n    \n\n\n\ntry:\n    with Image.open(false_color_filename_tif) as img:\n        print(f\"False-color TIFF mode: {img.mode}, size: {img.size}\")\n        img.convert(\"RGB\").save(false_color_filename_png)\n        print(f\"False-color PNG saved at {false_color_filename_png}\")\nexcept Exception as e:\n    print(f\"Error converting false-color TIFF to PNG: {e}\")\n\ntry:\n    with Image.open(flooded_pixels_filename_tif) as img:\n        print(f\"Flooded pixels TIFF mode: {img.mode}, size: {img.size}\")\n        img.convert(\"RGB\").save(flooded_pixels_filename_png)\n        print(f\"Flooded pixels PNG saved at {flooded_pixels_filename_png}\")\nexcept Exception as e:\n    print(f\"Error converting flooded pixels TIFF to PNG: {e}\")\n\n: \n\n\nreport and map directories and file names\n\n# directory location for reports\nhtml_subdirectory = \"flood_reports/html_reports_maps\"\nos.makedirs(html_subdirectory, exist_ok=True)\n\n\n# Define filenames with unique names based on the image date\nreport_filename = os.path.join(html_subdirectory, f\"bwma_flood_report_{image_date_str}_{threshold}.html\")\nmap_filename = os.path.join(html_subdirectory, f\"flooded_area_map_{image_date_str}_{threshold}.html\")\n\n\n            \n            \n\n\nCreate a cloud-free composite by masking cloudy pixels\n\n\n\n\ndef mask_clouds(image):\n    cloud_prob = image.select('SCL')  # Scene Classification Layer (SCL)\n    is_cloud = cloud_prob.eq(9)  # 9 represents clouds in the SCL\n    return image.updateMask(is_cloud.Not())\n\ncloud_free_composite = sentinel_collection.map(mask_clouds).median()\n\n\n            \n            \n\n\nDefine binary image base on the threshold\n\nbinary_image = cloud_free_composite.select('B8').divide(10000).lt(threshold).selfMask()\n\n\n            \n            \n\n\nLoad units from geojson and convert to earth engine geometry\n\ngdf = gpd.read_file(\"data/unitsBwma2800.geojson\")\nunits = geemap.geopandas_to_ee(gdf)\nunits = units.filterBounds(bounding_box_geometry)\nunits_clipped = units.map(lambda feature: feature.intersection(bounding_box_geometry))\n\n\n            \n            \n\n\nCompute the unit area and flooded area\n\n# Compute area of each unit\ndef compute_area(feature):\n    return feature.set({'unit_acres': feature.geometry().area().divide(4046.86)})\n\nunits_with_area = units_clipped.map(compute_area)\n\n# Compute the flooded area within each unit\ndef compute_refined_flood_area(feature):\n    geom = feature.geometry()\n    total_pixels = cloud_free_composite.select('B8').reduceRegion(\n        reducer=ee.Reducer.count(), geometry=geom, scale=10).get('B8')\n    flooded_pixels = binary_image.reduceRegion(\n        reducer=ee.Reducer.count(), geometry=geom, scale=10).get('B8')\n    pixel_area_m2 = ee.Number(pixel_size).multiply(pixel_size)\n    pixel_area_acres = pixel_area_m2.multiply(0.000247105)\n    flooded_area_acres = ee.Number(flooded_pixels).multiply(pixel_area_acres)\n    flooded_percentage = ee.Number(flooded_pixels).divide(total_pixels).multiply(100)\n    unit_name = feature.get('Flood_Unit')\n    label = ee.String(unit_name).cat(': ').cat(flooded_area_acres.format('%.2f')).cat(' Acres')\n    return feature.set({\n        'total_pixels': total_pixels,\n        'flooded_pixels': flooded_pixels,\n        'acres_flooded': flooded_area_acres,\n        'flooded_percentage': flooded_percentage,\n        'label': label\n    })\n\nunits_with_calculations = units_with_area.map(compute_refined_flood_area)\n\n\n            \n            \n\n\nConvert EE feature collection to Pandas DataFrame\n\n\nunits_df_properties_reduced = pd.DataFrame(units_with_calculations.getInfo()['features'])\nunits_df_properties_reduced = pd.json_normalize(units_df_properties_reduced['properties'])\nunits_df_properties_reduced = units_df_properties_reduced[['Flood_Unit', 'total_pixels', 'flooded_pixels', 'unit_acres', 'acres_flooded', 'flooded_percentage']]\n\n# Round numbers\nunits_df_properties_reduced = units_df_properties_reduced.round(2)\n\n\n            \n            \n\n\nCalculate Total Acreage and add total row\n\n# Calculate totals\ntotal_acres = units_df_properties_reduced['unit_acres'].sum()\ntotal_flooded_acres = units_df_properties_reduced['acres_flooded'].sum()\ntotal_flooded_percentage = (total_flooded_acres / total_acres) * 100\n\n# Add a row for totals\ntotals = pd.DataFrame([{\n    'Flood_Unit': 'Total',\n    'total_pixels': units_df_properties_reduced['total_pixels'].sum(),\n    'flooded_pixels': units_df_properties_reduced['flooded_pixels'].sum(),\n    'unit_acres': total_acres,\n    'acres_flooded': total_flooded_acres,\n    'flooded_percentage': total_flooded_percentage\n}])\n\n# Concatenate totals to the original dataframe\nunits_df_properties_reduced = pd.concat([units_df_properties_reduced, totals], ignore_index=True)\n\n# Round the totals row\nunits_df_properties_reduced = units_df_properties_reduced.round(2)\n\n# Display the formatted DataFrame\nprint(units_df_properties_reduced.to_string(index=False))\n\n\n\n            \n            \n\n\n     Flood_Unit  total_pixels  flooded_pixels  unit_acres  acres_flooded  flooded_percentage\n        Thibaut         99955            6526     1971.07         161.26                6.53\n           Drew         25462             768      502.65          18.98                3.02\n      Waggonner         63198            4429     1246.13         109.44                7.01\n West Winterton         40855            2080      805.68          51.40                5.09\n East Winterton         17010              19      335.14           0.47                0.11\nSouth Winterton         26035            1337      513.46          33.04                5.14\n  Thibaut Ponds         26753            1309      527.63          32.35                4.89\n          Total        299268           16468     5901.76         406.94                6.90\n\n\nCreate and Save HTML Map\n\n#cloud_free_composite = sentinel_collection.map(lambda img: img.updateMask(img.select('SCL').neq(9))).median()\n\n#binary_image = cloud_free_composite.select('B8').divide(10000).lt(threshold).selfMask()\n# Define export file paths with date and threshold\nfalse_color_filename_tif = f\"docs/reports/false_color_composite_{image_date_str}_{threshold}.tif\"\nflooded_pixels_filename_tif = f\"docs/reports/flooded_pixels_{image_date_str}_{threshold}.tif\"\n    \nfalse_color_filename_png = f\"docs/reports/false_color_composite_{image_date_str}_{threshold}.png\"\nflooded_pixels_filename_png = f\"docs/reports/flooded_pixels_{image_date_str}_{threshold}.png\"\n# Export false-color composite as TIF with the correct bands\nfalse_color_image = cloud_free_composite.select(['B11', 'B8', 'B4']).visualize(**false_color_vis)\n\n\n            \n            \n\n\n\n\ngeemap.ee_export_image(false_color_image, filename=false_color_filename_tif, scale=10, region=bbox)\n\n\n\n            \n            \n\n\nGenerating URL ...\nDownloading data from https://earthengine.googleapis.com/v1/projects/ee-icwd-2023/thumbnails/cca305bcebf78bc407e668aa5a486d40-143f27f87326f62fdb0aa0bf1d16e281:getPixels\nPlease wait ...\nData downloaded to c:\\Users\\znelson\\Documents\\inyo-gov\\flooded-acreage\\docs\\reports\\false_color_composite_2024-10-22_0.21.tif\n\n\n\n\n# Step 1: Select the 'B8' band and multiply by 255 for visualization scaling\nflooded_pixels_band = binary_image.select('B8').multiply(255)\n\n# Step 2: Rename the band to ensure compatibility with visualize\nflooded_pixels_band = flooded_pixels_band.rename(['visualized'])\n\n# Step 3: Create the visualized image separately\nflooded_pixels_visualized = flooded_pixels_band.visualize(\n    bands=['visualized'],\n    palette=['blue'],\n    min=0,\n    max=255\n)\n\n# Step 4: Export the visualized image\ngeemap.ee_export_image(flooded_pixels_visualized, filename=flooded_pixels_filename_tif, scale=10, region=bbox)\n\n\n            \n            \n\n\nGenerating URL ...\nDownloading data from https://earthengine.googleapis.com/v1/projects/ee-icwd-2023/thumbnails/0a8a39aa13ea87648748a473985daf7a-8bd8c61ea2cb58724b5e05482b195566:getPixels\nPlease wait ...\nData downloaded to c:\\Users\\znelson\\Documents\\inyo-gov\\flooded-acreage\\docs\\reports\\flooded_pixels_2024-10-22_0.21.tif\n\n\n\nfrom PIL import Image\nimport os\n\nfalse_color_filename_tif = \"docs/reports/false_color_composite_2024-11-03_0.23.tif\"\nflooded_pixels_filename_tif = \"docs/reports/flooded_pixels_2024-11-03_0.23.tif\"\nfalse_color_filename_png = \"docs/reports/false_color_composite_2024-11-03_0.23.png\"\nflooded_pixels_filename_png = \"docs/reports/flooded_pixels_2024-11-03_0.23.png\"\n\ntry:\n    with Image.open(false_color_filename_tif) as img:\n        img.save(false_color_filename_png)\n        print(\"False-color PNG created successfully.\")\n    with Image.open(flooded_pixels_filename_tif) as img:\n        img.save(flooded_pixels_filename_png)\n        print(\"Flooded pixels PNG created successfully.\")\nexcept Exception as e:\n    print(f\"Error during TIF to PNG conversion: {e}\")\n\n\n            \n            \n\n\n: \n\n\n\nprint(binary_image.getInfo())\n\n\n            \n            \n\n\n{'type': 'Image', 'bands': [{'id': 'B8', 'data_type': {'type': 'PixelType', 'precision': 'int', 'min': 0, 'max': 1}, 'crs': 'EPSG:4326', 'crs_transform': [1, 0, 0, 0, 1, 0]}]}\n\n\n\n\n# Convert TIF to PNG\nwith Image.open(false_color_filename_tif) as img:\n    img.save(false_color_filename_png)\nwith Image.open(flooded_pixels_filename_tif) as img:\n    img.save(flooded_pixels_filename_png)\n\n\n# Export false-color composite as TIF with the correct bands\n# Use the cloud_free_composite with specific bands and visualize settings\nfalse_color_image = cloud_free_composite.select(['B11', 'B8', 'B4']).visualize(**false_color_vis)\ngeemap.ee_export_image(false_color_image, filename=false_color_filename_tif, scale=10, region=bbox)\n\n\n            \n            \n\n\nNameError: name 'false_color_filename_tif' is not defined\n\n\n\n\n# Export flooded pixels as TIF with visualization parameters (ensure the 'B8' band is used)\n# This ensures that a proper color palette is applied to the binary mask\nflooded_pixels_image = binary_image.select('B8').visualize({'palette': ['blue'], 'min': 0, 'max': 1})\ngeemap.ee_export_image(flooded_pixels_image, filename=flooded_pixels_filename_tif, scale=10, region=bbox)\n\n\n# Define visualization parameters for a better false-color composite\nfalse_color_vis = {\n    'min': 0,\n    'max': 3000,\n    'bands': ['B11', 'B8', 'B4'],  # SWIR1 (B11), NIR (B8), Red (B4)\n    'gamma': 1.4\n}\n\n# Create the Sentinel-2 image collection filtered by date, cloud cover, and bounds\nsentinel_collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterBounds(bounding_box_geometry) \\\n    .filterDate(start_date, end_date) \\\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)) \\\n    .select(['B8', 'B11', 'B4', 'SCL'])  # Select NIR (B8), SWIR1 (B11), Red (B4), and Scene Classification Layer (SCL)\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the false-color composite to the map\nMap.addLayer(sentinel_collection.median(), false_color_vis, 'False-Color Composite')\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map with Layer Control\nMap.add_child(folium.LayerControl())\n\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\n\n\n\n\n\nfalse_color_vis = {\n    'min': 0,\n    'max': 3000,\n    'bands': ['B11', 'B8', 'B4'],  # SWIR1 (B11), NIR (B8), Red (B4)\n    'gamma': 1.4\n}\n\n# Create the Sentinel-2 image collection filtered by date, cloud cover, and bounds\nsentinel_collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \\\n    .filterBounds(bounding_box_geometry) \\\n    .filterDate(start_date, end_date) \\\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30)) \\\n    .select(['B8', 'B11', 'B4', 'SCL'])  # Select NIR (B8), SWIR1 (B11), Red (B4), and Scene Classification Layer (SCL)\n\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the false-color image to the map (assuming 'image' is your Sentinel-2 or equivalent image)\nMap.addLayer(image, false_color_vis, 'False-Color Composite')\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map with Layer Control\nMap.add_child(folium.LayerControl())\n\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\nNameError: name 'image' is not defined\n\n\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map\nMap.add_child(folium.LayerControl())\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\n\n\n\n\n\n# Clip the binary image to the unit boundaries\nclipped_binary_image = binary_image.clip(units)\n\n# Create a folium map\nMap = geemap.Map(center=[36.8795, -118.202], zoom=12)\n\n# Add the clipped binary image to the map\nMap.addLayer(clipped_binary_image, {'palette': ['blue'], 'opacity': 0.5}, 'Flooded Pixels')\n\n# Style for unit boundaries\nunits_style = {'color': 'red', 'fillColor': '00000000'}  # '00000000' is transparent in RGBA\n\n# Add the unit boundaries to the map\nMap.addLayer(units_with_calculations.style(**units_style), {}, 'Unit Boundaries')\n\n# Add labels to the map\nlabels = units_with_calculations.aggregate_array('label').getInfo()\n\n# Extract centroids for each feature\ndef get_centroid(feature):\n    return feature.geometry().centroid().coordinates()\n\ncentroids = units_with_calculations.map(lambda f: f.set('centroid', get_centroid(f)))\n\n# Get the centroids information\ncentroid_info = centroids.aggregate_array('centroid').getInfo()\n\nfor label, centroid in zip(labels, centroid_info):\n    folium.Marker(\n        location=[centroid[1], centroid[0]],\n        icon=None,\n        popup=label\n    ).add_to(Map)\n\n# Display the map\nMap.add_child(folium.LayerControl())\n# Save the map to the subdirectory with a unique name\nMap.save(map_filename)\nMap\n\n\n            \n            \n\n\n\n\n\n\nWrite csv Table\n\n\n# Define the subdirectory for CSV output\ncsv_subdirectory = \"flood_reports/csv_output\"\nos.makedirs(csv_subdirectory, exist_ok=True)\n\n# Save the DataFrame to a CSV file\nunits_df_properties_reduced = pd.DataFrame(units_with_calculations.getInfo()['features'])\nunits_df_properties_reduced = pd.json_normalize(units_df_properties_reduced['properties'])\nunits_df_properties_reduced = units_df_properties_reduced[['Flood_Unit', 'total_pixels', 'flooded_pixels', 'unit_acres', 'acres_flooded']]\n\n# Define the CSV filename with the new directory\ncsv_filename = os.path.join(csv_subdirectory, f'flood_report_data_{image_date_str}_{threshold}.csv')\n\n# csv_filename = f'flood_report_data_{image_date_str}.csv'\nunits_df_properties_reduced.to_csv(csv_filename, index=False)\n\n\n            \n            \n\n\nCreate HTML Table\n\n\n# Rename columns for display\nunits_df_properties_reduced = units_df_properties_reduced[['Flood_Unit', 'acres_flooded']]\nunits_df_properties_reduced.columns = ['BWMA Unit', 'Acres']\n\n# Round acres to whole numbers\nunits_df_properties_reduced['Acres'] = units_df_properties_reduced['Acres'].round(0).astype(int)\n\n# Calculate totals\ntotal_acres = units_df_properties_reduced['Acres'].sum()\ntotals_row = pd.DataFrame([{'BWMA Unit': 'Total', 'Acres': total_acres}])\n\n# Append the totals row to the DataFrame\nunits_df_properties_reduced = pd.concat([units_df_properties_reduced, totals_row], ignore_index=True)\n\n\n# Style the DataFrame and convert to HTML\nhtml_table_simple = (\n    units_df_properties_reduced.style\n    .set_table_styles([\n        {'selector': 'th', 'props': [('text-align', 'center'), ('font-size', '14px')]},\n        {'selector': 'td:nth-child(1)', 'props': [('text-align', 'left'), ('font-size', '12px')]},\n        {'selector': 'td:nth-child(2)', 'props': [('text-align', 'right'), ('font-size', '12px')]},\n    ])\n    .set_properties(subset=pd.IndexSlice[units_df_properties_reduced.index[-1], :], **{'font-weight': 'bold', 'font-size': '14px'})\n    .hide(axis='index')\n    .to_html()\n)\n\n\n# Manually hide the index in the HTML string\nhtml_table_simple = html_table_simple.replace('&lt;th&gt;&lt;/th&gt;', '')\n\n\n            \n            \n\n\nCreate HTML Report\n\n\n\n# HTML report\nhtml_report = f\"\"\"\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;BWMA Flooded Extent: {image_date_str}&lt;/title&gt;\n    &lt;style&gt;\n        body {{\n            font-family: Arial, sans-serif;\n        }}\n        .container {{\n            display: flex;\n            justify-content: space-between;\n        }}\n        .left {{\n            width: 25%;\n        }}\n        .right {{\n            width: 75%;\n            text-align: center;\n        }}\n        h1, h2 {{\n            text-align: center;\n        }}\n        .notes {{\n            margin-top: 20px;\n            padding: 10px;\n            border-top: 1px solid #000;\n        }}\n        /*----CHANGE---- Increase font size and add line above totals row */\n        table {{\n            width: 90%;\n            font-size: 50px;\n            border-collapse: collapse;\n        }}\n        th, td {{\n            padding: 20px;\n            text-align: left;\n            border-bottom: 1px solid #ddd;\n        }}\n        th {{\n            text-align: right;//from center\n            font-size: 30px;\n        }}\n        td:nth-child(2) {{\n            text-align: right;\n        }}\n        tr:last-child {{\n            font-weight: bold;\n            font-size: 80px;\n        }}\n        tr:last-child td {{\n            border-top: 3px solid #000;\n        }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;BWMA Flooded Acres and Extent: {image_date_str}&lt;/h1&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"left\"&gt;\n            &lt;h2&gt;Flooded Acres&lt;/h2&gt;\n            {html_table_simple}\n        &lt;/div&gt;\n        &lt;div class=\"right\"&gt;\n            &lt;h2&gt;Spatial Extent&lt;/h2&gt;\n            &lt;p&gt;Imagery Date: {image_date_str}&lt;/p&gt;\n            &lt;iframe src=\"flooded_area_map_{image_date_str}_{threshold}.html\" width=\"90%\" height=\"500\"&gt;&lt;/iframe&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"notes\"&gt;\n        &lt;h3&gt;Technical Notes&lt;/h3&gt;\n        &lt;p&gt;Flooded acres were calculated from Sentinel-2 Surface Reflectance imagery using the Earth Engine Python API in a Jupyter notebook.  Sentinel-2 (S2) is a wide-swath, high-resolution, multispectral imaging mission with a global 5-day revisit frequency.&lt;/p&gt;\n        &lt;p&gt;The S2 Multispectral Instrument (MSI) samples 13 spectral bands: Visible and NIR at 10 meters, red edge and SWIR at 20 meters, and atmospheric bands at 60 meters spatial resolution. The Near Infrared (NIR) band was used to identify flooded areas by applying a threshold to isolate water.&lt;/p&gt;\n        &lt;p&gt;The results are validated during routine field checks throughout the seasonal flooding cycle September through April.&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n# Save the report to an HTML file in the subdirectory\nwith open(report_filename, \"w\") as file:\n    file.write(html_report)\n\nprint(f\"Report saved to {report_filename}\")\nprint(f\"Map saved to {map_filename}\")\n\n\n            \n            \n\n\nReport saved to flood_reports/html_reports_maps\\bwma_flood_report_2024-09-22_0.21.html\nMap saved to flood_reports/html_reports_maps\\flooded_area_map_2024-09-22_0.21.html"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Technical Notes\n\nFlooded acres were calculated from Sentinel-2 Surface Reflectance imagery using the Earth Engine Python API. Sentinel-2 (S2) is a wide-swath, high-resolution, multispectral imaging mission with a global 5-day revisit frequency. The S2 Multispectral Instrument (MSI) samples 13 spectral bands: Visible and NIR at 10 meters, red edge and SWIR at 20 meters, and atmospheric bands at 60 meters spatial resolution.\nThe Near Infrared (NIR) band with 10m pixel resolution was used to identify flooded areas by applying a reflectance threshold to isolate water from surrounding vegetation. The flooded extent predictions are verified in the field during avian surveys throughout the seasonal flooding cycle September through April."
  },
  {
    "objectID": "scratch.html",
    "href": "scratch.html",
    "title": "flooded-acreage",
    "section": "",
    "text": "import imageio\n\n# Read the TIFF file\ntiff_image = imageio.imread(\"docs/reports/false_color_composite_2024-11-08_0.22.tif\")\n\nC:\\Users\\znelson\\AppData\\Local\\Temp\\ipykernel_13404\\1139790178.py:4: DeprecationWarning: Starting with ImageIO v3 the behavior of this function will switch to that of iio.v3.imread. To keep the current behavior (and make this warning disappear) use `import imageio.v2 as imageio` or call `imageio.v2.imread` directly.\n  tiff_image = imageio.imread(\"docs/reports/false_color_composite_2024-11-08_0.22.tif\")\n\n\n\n\n# Save the image as a PNG file\nimageio.imwrite(\"docs/reports/false_color_composite_2024-11-08_0.22.png\", tiff_image)"
  },
  {
    "objectID": "index.html#read-all-of-the-csv-exports-into-monthly_raw",
    "href": "index.html#read-all-of-the-csv-exports-into-monthly_raw",
    "title": "Blackrock Waterfowl Management Area - Flooded Acreage",
    "section": "",
    "text": "fiscal_year\nJul\nAug\nSep\nOct\nNov\nDec\nJan\nFeb\nMar\nApr\nMay\nJun\n\n\n\n\n2025\n\n\nSeptember 22\nOctober 22\nNovember 03, November 08, November 13, November 16, November 18, November 28\nDecember 06\nJanuary 05\nFebruary 21\nMarch 01, March 08, March 15 , March 26\nApril 04\nMay 02, May 20\nJune 04\n\n\n\n\n\n\n\n\n# (A) Fix spelling typo and “floor” each report_date to the first of that month\nmonthly_fixed &lt;- monthly_raw %&gt;%\n  mutate(\n    Flood_Unit = recode(Flood_Unit,\n                       \"Waggonner\" = \"Waggoner\",\n                       .default    = Flood_Unit),\n    month_date = floor_date(report_date, unit = \"month\")\n  )\n\n# (B) Compute average flooded acres per (Flood_Unit × month_date)\nmonthly_avg &lt;- monthly_fixed %&gt;% filter(Flood_Unit != \"Total\") %&gt;% \n  group_by(Flood_Unit, month_date) %&gt;%\n  summarize(\n    avg_acres = mean(acres_flooded, na.rm = TRUE),\n    .groups   = \"drop\"\n  )\n\n# (C) Plot as stacked bars plus dashed “500 ac target” line from Nov 1 → Mar 1\nggplot(monthly_avg, aes(x = month_date, y = avg_acres, fill = Flood_Unit)) +\n  geom_col() +\n  geom_segment(\n    aes(\n      x    = as.Date(\"2024-11-01\"),\n      xend = as.Date(\"2025-03-01\"),\n      y    = 500,\n      yend = 500\n    ),\n    color     = \"black\",\n    linetype  = \"dashed\",\n    size      = 0.7\n  ) +\n  annotate(\n    \"text\",\n    x     = as.Date(\"2025-01-01\"),\n    y     = 510,             # just above the dashed line\n    label = \"500 ac target\",\n    size  = 3.5,\n    hjust = 0.5\n  ) +\n  scale_x_date(\n    limits      = as.Date(c(\"2024-09-01\", \"2025-06-01\")),\n    date_breaks = \"1 month\",\n    date_labels = \"%b '%y\"   # “Sep '24”, “Oct '24”, … “Jun '25”\n  ) +\n  labs(\n    title = \"Average Flooded Acres by Unit (Sep 2024–Jun 2025)\",\n    x     = \"Month\",\n    y     = \"Average Acres Flooded\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\nWarning: Removed 14 rows containing missing values (`geom_col()`).\n\n\n\n\n\nBelow is a preview of a default flood report. Click on any report link above to view it directly in a new tab."
  }
]